package edu.tyut.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.TooManyListenersException;

import gnu.io.CommPortIdentifier;
import gnu.io.PortInUseException;
import gnu.io.SerialPort;
import gnu.io.SerialPortEvent;
import gnu.io.SerialPortEventListener;
import gnu.io.UnsupportedCommOperationException;

/**
 * 串口参数的配置 串口一般有如下参数可以在该串口打开以前进行配置： 包括串口号，波特率，输入/输出流控制，数据位数，停止位和奇偶校验。
 */
// 注：串口操作类一定要继承SerialPortEventListener
public class SerialPortUtils implements SerialPortEventListener {
	// 检测系统中可用的通讯端口类
	private CommPortIdentifier commPortId;
	// 枚举类型
	private Enumeration<CommPortIdentifier> portList;
	// RS232串口
	private SerialPort serialPort;
	// 输入流
	private InputStream inputStream;
	// 输出流
	private OutputStream outputStream;
	// 保存串口返回信息
	private String data;
	// 保存串口返回信息十六进制
	private String dataHex;

	public void setDataHex(String dataHex) {
		this.dataHex = dataHex;
	}

	/**
	 * 初始化串口 @author LinWenLi @date 2018年7月21日下午3:44:16 @Description: TODO @param:
	 * paramConfig 存放串口连接必要参数的对象（会在下方给出类代码） @return: void @throws
	 * 
	 * @throws Exception
	 */
	@SuppressWarnings("unchecked")
	public void init(ParamConfig paramConfig) throws Exception {
		// 获取系统中所有的通讯端口
		portList = CommPortIdentifier.getPortIdentifiers();
		// 记录是否含有指定串口
		boolean isExsist = false;
		// 循环通讯端口
		while (portList.hasMoreElements()) {
			commPortId = portList.nextElement();
			// 判断是否是串口
			if (commPortId.getPortType() == CommPortIdentifier.PORT_SERIAL) {
				// 比较串口名称是否是指定串口
				if (paramConfig.getSerialNumber().equals(commPortId.getName())) {
					// 串口存在
					isExsist = true;
					// 打开串口
					try {
						// open:（应用程序名【随意命名】，阻塞时等待的毫秒数）
						serialPort = (SerialPort) commPortId.open(Object.class.getSimpleName(), 2000);
						// 设置串口监听
						serialPort.addEventListener(this);
						// 设置串口数据时间有效(可监听)
						serialPort.notifyOnDataAvailable(true);
						// 设置串口通讯参数:波特率，数据位，停止位,校验方式
						serialPort.setSerialPortParams(paramConfig.getBaudRate(), paramConfig.getDataBit(),
								paramConfig.getStopBit(), paramConfig.getCheckoutBit());
					} catch (PortInUseException e) {
						throw new Exception("端口被占用");
					} catch (TooManyListenersException e) {
						throw new Exception("监听器过多");
					} catch (UnsupportedCommOperationException e) {
						throw new Exception("不支持的COMM端口操作异常");
					}
					// 结束循环
					break;
				}
			}
		}
		// 若不存在该串口则抛出异常
		if (!isExsist) {
			try {
				throw new Exception("不存在该串口！");
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	/**
	 * 实现接口SerialPortEventListener中的方法 读取从串口中接收的数据
	 */
	@Override
	public void serialEvent(SerialPortEvent event) {
		switch (event.getEventType()) {
		case SerialPortEvent.BI: // 通讯中断
		case SerialPortEvent.OE: // 溢位错误
		case SerialPortEvent.FE: // 帧错误
		case SerialPortEvent.PE: // 奇偶校验错误
		case SerialPortEvent.CD: // 载波检测
		case SerialPortEvent.CTS: // 清除发送
		case SerialPortEvent.DSR: // 数据设备准备好
		case SerialPortEvent.RI: // 响铃侦测
		case SerialPortEvent.OUTPUT_BUFFER_EMPTY: // 输出缓冲区已清空
			break;
		case SerialPortEvent.DATA_AVAILABLE: // 有数据到达
			// 调用读取数据的方法
			try {
				readComm();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			break;
		default:
			break;
		}
	}

	/**
	 * 读取串口返回信息
	 * 
	 * @author LinWenLi
	 * @date 2018年7月21日下午3:43:04
	 * @return: void
	 *
	 */
	public String readComm() throws Exception {
		try {
			inputStream = serialPort.getInputStream();
			// 通过输入流对象的available方法获取数组字节长度
			byte[] readBuffer = new byte[inputStream.available()];
			// 从线路上读取数据流
			int len = 0;
			while ((len = inputStream.read(readBuffer)) != -1) {
				// 直接获取到的数据
				data = new String(readBuffer, 0, len).trim();
				// 转化为十六进制
				dataHex = TypeTrans.bytesToHexString(readBuffer);
				// System.out.println("data:" + data);
				// System.out.println("dataHex:" + dataHex);// 读取后置空流对象
				// System.out.println("temperature:" + TypeTrans.tempaerature(dataHex));
				// System.out.println("humidity:" + TypeTrans.humidity(dataHex) + "%");
				inputStream.close();
				inputStream = null;
				break;
			}
		} catch (IOException e) {
			throw new Exception("读取串口数据时发生IO异常");
		}
		return dataHex;
	}

	/**
	 * 发送信息到串口 @author LinWenLi @date 2018年7月21日下午3:45:22 @param: data @return:
	 * void @throws
	 * 
	 * 
	 */
	public void sendComm(String data) throws Exception {
		byte[] writerBuffer = null;

		try {
			writerBuffer = TypeTrans.hexToByteArray(data);
			System.out.println(writerBuffer);
		} catch (NumberFormatException e) {
			throw new Exception("命令格式错误！");
		}
		try {
			outputStream = serialPort.getOutputStream();
			outputStream.write(writerBuffer);
			outputStream.flush();
		} catch (NullPointerException e) {
			throw new Exception("找不到串口。");
		} catch (IOException e) {
			throw new Exception("发送信息到串口时发生IO异常");
		}
	}

	/**
	 * 关闭串口 @author LinWenLi @date 2018年7月21日下午3:45:43 @Description:
	 * 关闭串口 @param: @return: void @throws
	 * 
	 * @throws Exception
	 */
	public void closeSerialPort() throws Exception {
		if (serialPort != null) {
			serialPort.notifyOnDataAvailable(false);
			serialPort.removeEventListener();
			if (inputStream != null) {
				try {
					inputStream.close();
					inputStream = null;
				} catch (IOException e) {
					throw new Exception("关闭输入流时发生IO异常");
				}
			}
			if (outputStream != null) {
				try {
					outputStream.close();
					outputStream = null;
				} catch (IOException e) {
					throw new Exception("关闭输出流时发生IO异常");
				}
			}
			serialPort.close();
			serialPort = null;
		}
	}

	/**
	 * 十六进制串口返回值获取
	 */
	public String getDataHex() {
		String result = dataHex;
		// 置空执行结果
		dataHex = null;
		// 返回执行结果
		return result;
	}

	/**
	 * 串口返回值获取
	 */
	public String getData() {
		String result = data;
		// 置空执行结果
		data = null;
		// 返回执行结果
		return result;
	}

}
